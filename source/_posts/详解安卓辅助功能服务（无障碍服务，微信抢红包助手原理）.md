---
title: 详解安卓辅助功能服务（无障碍服务，微信抢红包助手原理）
date: 2020-05-21 16:52:15
tags: [Android]
---

# 前言

在手机的更多设置或者高级设置中，我们会发现有个无障碍的功能，很多人不知道这个功能具体是干嘛的，包括我们开发也很少接触这部分功能，以至于对这块不甚了解。前段时间在汉光的安利下去了解了下这部分功能。在这里和大家浅谈下自己对这个功能的理解和部分运用。这边打算从 “是什么，为什么，怎么用，好不好”几个方面来说

# 提纲

是什么（应用场景，定义，作用）

为什么（原理及源码解析）

怎么用（如何开发无障碍服务）

怎么防（防止无障碍服务外挂的一些做法）

## 是什么（定位及作用）  

为了更好的介绍辅助功能服务，这里先看下应用场景

辅助功能服务一般用于操作自动化和辅助操作

•应用场景

Ø操作自动化，通过辅助功能服务来代替用户执行连续性的操作，重复性的操作，或者特殊场景的操作（例如自动抢红包，自动点赞，自动回复，自动搜索更优惠商品）

[WechatHelper](https://github.com/coder-pig/WechatHelper)  https://github.com/coder-pig/WechatHelper

Ø辅助操作，帮助无法和设备完全交互的用户（例如患有视力问题或正在忙而无法操作手机的用户）执行操作（例如talkback（视力低弱辅助），随选听读，语音操作）

![img](https://upload-images.jianshu.io/upload_images/5714046-67b42e781d3f1e8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

•官方定义（AccessibilityService）

无障碍服务是一种应用程序，给有残疾的用户或暂时无法与设备完全交互的用户提供了更好的无障碍用户交互功能。比如驾驶、照顾小孩或者在吵闹的派对上可能需要额外或者替代的交互反馈。

Android提供标准的辅助功能服务，包括TalkBack，开发人员可以创建和分发自己的服务。

•引入及发展

![img](https://upload-images.jianshu.io/upload_images/5714046-da08f8e0c23d7365.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

在Android 4.0以前，Accessibility功能单一，仅能过单向获取窗口信息(获取输入框内容)；

在Android 4.0及以后，Accessibility增加了与窗口元素的双向交互，可以操作窗口元素(点击按钮)。

在Android 4.0之前，无障碍服务事件在提供有关用户选择的用户界面控件的信息时，只提供了有限的上下文信息。在许多情况下，缺少的上下文信息可能对理解所选控件的含义至关重要。

Android 4.0通过基于视图层次结构组合可访问性事件，显着扩展了辅助功能服务可以获得的有关用户界面交互的信息量。

辅助功能服务可以代表用户执行操作，包括更改输入焦点和选择（激活）用户界面元素。在Android

4.1（API级别16）中，操作范围已扩展为包括滚动列表和与文本字段交互。

![img](https://upload-images.jianshu.io/upload_images/5714046-7cf34ceee1ad67cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

因为无障碍服务具有强大的界面监听能力和替代用户操作的能力，谷歌建议辅助功能服务仅应用于帮助残障用户使用Android设备和应用。

在我们开发者看来，无障碍服务显然能做的更多，例如微信抢红包应用，自动点赞，自动回复等

android 辅助功能google官方示例 https://github.com/googlesamples/android-BasicAccessibility

## 为什么（原理及源码解析） 

Q:为什么辅助功能可以监听用户的操作，界面变化，并根据需要进行反馈

A:辅助功能通过在后台中运行无障碍服务，通过AccessibilityEvent接收指定事件的回调，这样的事件表示用户在界面中的一些状态转换，例如：焦点改变了，一个按钮被点击，等等。

简单的说无障碍就是一个后台监控服务，当你监控的内容发生改变时，就会调用后台服务的回调方法

### 从具体实例入手看原理： 程序内部的后台服务—— 内部的跨进程通信 AM & AMS

拿一个具体的例子来看，这是一个抢红包的外挂，把WeChat称作Target

APP，就是被监控的APP，当跳出来一个红包，触发了一个AccessibilityEvent，system_server中的AccessibilityManagerService将AccessibilityEvent分发给有AccessibilityService的APP，称为Accessibility

APP，这个AccessibilityService受到这个AccessibilityEvent后，会找到这个页面的Open

Button，模拟点击。

![img](https://upload-images.jianshu.io/upload_images/5714046-68a84a9217903800.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



而在程序内部，这个过程其实就是三个类之间的交互 AccessibilityManager（AM）：发送AccessibilityEvent AccessibilityManagerService（AMS）：分发事件 AccessibilityService（AS）：进行回应 

![img](https://upload-images.jianshu.io/upload_images/5714046-a24a6a543f28d46c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

看到AccessibilityManagerService这样的起名，就很容易联想到，这是一个**Binder通信**的过程，AM通过IAccessibilityManager（AMS的本地Binder）与AMS跨进程通信。AMS通过IAccessibilityManagerClient（AM的本地Binder）与AM通信。

![img](https://upload-images.jianshu.io/upload_images/5714046-cecbb43dd2b74bf8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### **AM是与AMS进行通信**

AM是什么时候与AMS进行通信的，查看源码可以知道，AM的设计其实是一个单例模式，每个app进程都会有一个AM，而AM在构建的时候，即getInstance的时候，就会调用tryConnectToServiceLocked（）的方法，连接AMS，得到AMS的代理后，把自己的代理也设置给AMS，这样AM就可以和AMS进行通信了



![img](https://upload-images.jianshu.io/upload_images/5714046-344ab296134884d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### AS和AMS联系的时机 

那么**AS又是什么时候和AMS有联系的**呢，这又是一个跨进程binder通信的过程。

无障碍服务是很强大的服务，需要我们进到设置中开启这个服务。绑定Service。

这里我们结合时序图进行说明。

![img](https://upload-images.jianshu.io/upload_images/5714046-66a3d45196168203.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

Settings->Accessibility->enable（enableAccessibilityServiceLocked()）

Settings->Accessibility->disable（disableAccessibilityServiceLocked()）

Some RegisterBroadcastReceivers （registerBroadcastReceivers()）

当用户在设置->无障碍里面选择了开启或关闭一个辅助功能，会导致一些系统状态会变化；Accessibility APP的安装状态会以BroadcastReceivers的方式会通知状态改变；还有其他的一些状态改变。这些变化最终会调用到AMS的onUserStateChangedLocked()方法。

RegisterBroadcastReceivers 很多情况简单列为这四种，安装app，更新app。强制关闭app，删除app。

onUserStateChangedLocked方法中，有比较多的方法调用，都是一些特定状态的更新，但我们这次只用关注updateServicesLocked这个方法，是处理无障碍服务绑定的

![img](https://upload-images.jianshu.io/upload_images/5714046-bbd7e30f4f08a43c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


updateServicesLocked这个方法涉及到多个AMS类内部的集合，遍历如上图左边所见

这个方法会遍历ams中的mInstalledServices，看名字可以知道是已经安装的无障碍服务列表。

然后根据enableServices，判断是否已经启用，如果启用则通过mComponentNameToServiceMap判断是否为空，为空就会new一个AccessibilityServiceConnection， 调用其bindlock方法，绑定

未启用就通过mComponentNameToServiceMap判断是否为空，不为空就调用其unbindLocked()，解绑

![img](https://upload-images.jianshu.io/upload_images/5714046-d99e1a3e4eb92c2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



接下来的过程其实就是跨进程的Binder通信。AS会通过onBind(Intent intent)这个函数返回一个IAccessibilityServiceClientWrapper对象给AccessibilityServiceConnection，这个对象就是AS的本地Binder，AccessibilityServiceConnection通过这个本地Binder去和AS通信。

然后AccessibilityServiceConnection会在onServiceConnected中调用方法，把自己的代理传到AS中。

###  监听无障碍服务事件